{"ast":null,"code":"import { Touches } from './touches';\nimport { defaultProperties } from './properties';\nexport class IvyPinch {\n  constructor(properties) {\n    this.properties = defaultProperties;\n    this.i = 0;\n    this.scale = 1;\n    this.initialScale = 1;\n    this.startX = 0;\n    this.startY = 0;\n    this.moveX = 0;\n    this.moveY = 0;\n    this.initialMoveX = 0;\n    this.initialMoveY = 0;\n    this.moveXC = 0;\n    this.moveYC = 0;\n    this.lastTap = 0;\n    this.draggingMode = false;\n    this.distance = 0;\n    this.doubleTapTimeout = 0;\n    this.initialDistance = 0;\n    this.events = {};\n    this.defaultMaxScale = 3;\n    /* Touchstart */\n\n    this.handleTouchstart = event => {\n      this.touches.addEventListeners(\"mousemove\", \"handleMousemove\");\n      this.getElementPosition();\n\n      if (this.eventType === undefined) {\n        this.getTouchstartPosition(event);\n      }\n    };\n    /* Touchend */\n\n\n    this.handleTouchend = event => {\n      /* touchend */\n      if (event.type === \"touchend\") {\n        this.i = 0;\n        this.draggingMode = false;\n        const touches = event.touches; // Min scale\n\n        if (this.scale < 1) {\n          this.scale = 1;\n        } // Auto Zoom Out\n\n\n        if (this.properties.autoZoomOut && this.eventType === 'pinch') {\n          this.scale = 1;\n        } // Align image\n\n\n        if (this.eventType === 'pinch' || this.eventType === 'pan' && this.scale > this.minPanScale) {\n          this.alignImage();\n        } // Update initial values\n\n\n        if (this.eventType === 'pinch' || this.eventType === 'pan' || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\n          this.updateInitialValues();\n        }\n\n        this.eventType = 'touchend';\n\n        if (touches && touches.length === 0) {\n          this.eventType = undefined;\n        }\n      }\n      /* mouseup */\n\n\n      if (event.type === \"mouseup\") {\n        this.draggingMode = false;\n        this.updateInitialValues();\n        this.eventType = undefined;\n      }\n\n      this.touches.removeEventListeners(\"mousemove\", \"handleMousemove\");\n    };\n    /*\r\n     * Handlers\r\n     */\n\n\n    this.handlePan = event => {\n      if (this.scale < this.minPanScale || this.properties.disablePan) {\n        return;\n      }\n\n      event.preventDefault();\n      const {\n        clientX,\n        clientY\n      } = this.getClientPosition(event);\n\n      if (!this.eventType) {\n        this.startX = clientX - this.elementPosition.left;\n        this.startY = clientY - this.elementPosition.top;\n      }\n\n      this.eventType = 'pan';\n      this.moveX = this.initialMoveX + (this.moveLeft(event, 0) - this.startX);\n      this.moveY = this.initialMoveY + (this.moveTop(event, 0) - this.startY);\n\n      if (this.properties.limitPan) {\n        this.limitPanY();\n        this.limitPanX();\n      }\n      /* mousemove */\n\n\n      if (event.type === \"mousemove\" && this.scale > this.minPanScale) {\n        this.centeringImage();\n      }\n\n      this.transformElement(0);\n    };\n\n    this.handleDoubleTap = event => {\n      this.toggleZoom(event);\n      return;\n    };\n\n    this.handlePinch = event => {\n      event.preventDefault();\n\n      if (this.eventType === undefined || this.eventType === 'pinch') {\n        const touches = event.touches;\n\n        if (!this.eventType) {\n          this.initialDistance = this.getDistance(touches);\n          const moveLeft0 = this.moveLeft(event, 0);\n          const moveLeft1 = this.moveLeft(event, 1);\n          const moveTop0 = this.moveTop(event, 0);\n          const moveTop1 = this.moveTop(event, 1);\n          this.moveXC = (moveLeft0 + moveLeft1) / 2 - this.initialMoveX;\n          this.moveYC = (moveTop0 + moveTop1) / 2 - this.initialMoveY;\n        }\n\n        this.eventType = 'pinch';\n        this.distance = this.getDistance(touches);\n        this.scale = this.initialScale * (this.distance / this.initialDistance);\n        this.moveX = this.initialMoveX - (this.distance / this.initialDistance * this.moveXC - this.moveXC);\n        this.moveY = this.initialMoveY - (this.distance / this.initialDistance * this.moveYC - this.moveYC);\n        this.handleLimitZoom();\n\n        if (this.properties.limitPan) {\n          this.limitPanY();\n          this.limitPanX();\n        }\n\n        this.transformElement(0);\n      }\n    };\n\n    this.handleWheel = event => {\n      event.preventDefault();\n      let wheelZoomFactor = this.properties.wheelZoomFactor || 0;\n      let zoomFactor = event.deltaY < 0 ? wheelZoomFactor : -wheelZoomFactor;\n      let newScale = this.initialScale + zoomFactor;\n      /* Round value */\n\n      if (newScale < 1 + wheelZoomFactor) {\n        newScale = 1;\n      } else if (newScale < this.maxScale && newScale > this.maxScale - wheelZoomFactor) {\n        newScale = this.maxScale;\n      }\n\n      if (newScale < 1 || newScale > this.maxScale) {\n        return;\n      }\n\n      if (newScale === this.scale) {\n        return;\n      }\n\n      this.getElementPosition();\n      this.scale = newScale;\n      /* Get cursor position over image */\n\n      let xCenter = event.clientX - this.elementPosition.left - this.initialMoveX;\n      let yCenter = event.clientY - this.elementPosition.top - this.initialMoveY;\n      this.setZoom({\n        scale: newScale,\n        center: [xCenter, yCenter]\n      });\n    };\n\n    this.handleResize = _event => {\n      this.setAutoHeight();\n    };\n\n    this.element = properties.element;\n\n    if (!this.element) {\n      return;\n    }\n\n    this.elementTarget = this.element.querySelector('*').tagName;\n    this.parentElement = this.element.parentElement;\n    this.properties = Object.assign({}, defaultProperties, properties);\n    this.detectLimitZoom();\n    this.touches = new Touches({\n      element: properties.element,\n      listeners: properties.listeners,\n      resize: properties.autoHeight,\n      mouseListeners: {\n        \"mousedown\": \"handleMousedown\",\n        \"mouseup\": \"handleMouseup\",\n        \"wheel\": \"handleWheel\"\n      }\n    });\n    /* Init */\n\n    this.setBasicStyles();\n    /*\r\n     * Listeners\r\n     */\n\n    this.touches.on('touchstart', this.handleTouchstart);\n    this.touches.on('touchend', this.handleTouchend);\n    this.touches.on('mousedown', this.handleTouchstart);\n    this.touches.on('mouseup', this.handleTouchend);\n    this.touches.on('pan', this.handlePan);\n    this.touches.on('mousemove', this.handlePan);\n    this.touches.on('pinch', this.handlePinch);\n\n    if (this.properties.wheel) {\n      this.touches.on('wheel', this.handleWheel);\n    }\n\n    if (this.properties.doubleTap) {\n      this.touches.on('double-tap', this.handleDoubleTap);\n    }\n\n    if (this.properties.autoHeight) {\n      this.touches.on('resize', this.handleResize);\n    }\n  } // Minimum scale at which panning works\n\n\n  get minPanScale() {\n    return this.getPropertiesValue(\"minPanScale\");\n  }\n\n  get fullImage() {\n    return this.properties.fullImage;\n  }\n\n  handleLimitZoom() {\n    const limitZoom = this.maxScale;\n    const minScale = this.properties.minScale || 0;\n\n    if (this.scale > limitZoom || this.scale <= minScale) {\n      const imageWidth = this.getImageWidth();\n      const imageHeight = this.getImageHeight();\n      const enlargedImageWidth = imageWidth * this.scale;\n      const enlargedImageHeight = imageHeight * this.scale;\n      const moveXRatio = this.moveX / (enlargedImageWidth - imageWidth);\n      const moveYRatio = this.moveY / (enlargedImageHeight - imageHeight);\n\n      if (this.scale > limitZoom) {\n        this.scale = limitZoom;\n      }\n\n      if (this.scale <= minScale) {\n        this.scale = minScale;\n      }\n\n      const newImageWidth = imageWidth * this.scale;\n      const newImageHeight = imageHeight * this.scale;\n      this.moveX = -Math.abs(moveXRatio * (newImageWidth - imageWidth));\n      this.moveY = -Math.abs(-moveYRatio * (newImageHeight - imageHeight));\n    }\n  }\n\n  moveLeft(event, index = 0) {\n    const clientX = this.getClientPosition(event, index).clientX;\n    return clientX - this.elementPosition.left;\n  }\n\n  moveTop(event, index = 0) {\n    const clientY = this.getClientPosition(event, index).clientY;\n    return clientY - this.elementPosition.top;\n  }\n  /*\r\n   * Detection\r\n   */\n\n\n  centeringImage() {\n    const img = this.element.getElementsByTagName(this.elementTarget)[0];\n    const initialMoveX = this.moveX;\n    const initialMoveY = this.moveY;\n\n    if (this.moveY > 0) {\n      this.moveY = 0;\n    }\n\n    if (this.moveX > 0) {\n      this.moveX = 0;\n    }\n\n    if (img) {\n      this.limitPanY();\n      this.limitPanX();\n    }\n\n    if (img && this.scale < 1) {\n      if (this.moveX < this.element.offsetWidth * (1 - this.scale)) {\n        this.moveX = this.element.offsetWidth * (1 - this.scale);\n      }\n    }\n\n    return initialMoveX !== this.moveX || initialMoveY !== this.moveY;\n  }\n\n  limitPanY() {\n    const imgHeight = this.getImageHeight();\n    const scaledImgHeight = imgHeight * this.scale;\n    const parentHeight = this.parentElement.offsetHeight;\n    const elementHeight = this.element.offsetHeight;\n\n    if (scaledImgHeight < parentHeight) {\n      this.moveY = (parentHeight - elementHeight * this.scale) / 2;\n    } else {\n      const imgOffsetTop = (imgHeight - elementHeight) * this.scale / 2;\n\n      if (this.moveY > imgOffsetTop) {\n        this.moveY = imgOffsetTop;\n      } else if (scaledImgHeight + Math.abs(imgOffsetTop) - parentHeight + this.moveY < 0) {\n        this.moveY = -(scaledImgHeight + Math.abs(imgOffsetTop) - parentHeight);\n      }\n    }\n  }\n\n  limitPanX() {\n    const imgWidth = this.getImageWidth();\n    const scaledImgWidth = imgWidth * this.scale;\n    const parentWidth = this.parentElement.offsetWidth;\n    const elementWidth = this.element.offsetWidth;\n\n    if (scaledImgWidth < parentWidth) {\n      this.moveX = (parentWidth - elementWidth * this.scale) / 2;\n    } else {\n      const imgOffsetLeft = (imgWidth - elementWidth) * this.scale / 2;\n\n      if (this.moveX > imgOffsetLeft) {\n        this.moveX = imgOffsetLeft;\n      } else if (scaledImgWidth + Math.abs(imgOffsetLeft) - parentWidth + this.moveX < 0) {\n        this.moveX = -(imgWidth * this.scale + Math.abs(imgOffsetLeft) - parentWidth);\n      }\n    }\n  }\n\n  setBasicStyles() {\n    this.element.style.display = 'flex';\n    this.element.style.alignItems = 'center';\n    this.element.style.justifyContent = 'center';\n    this.element.style.transformOrigin = '0 0';\n    this.setImageSize();\n    this.setDraggableImage();\n  }\n\n  removeBasicStyles() {\n    this.element.style.display = '';\n    this.element.style.alignItems = '';\n    this.element.style.justifyContent = '';\n    this.element.style.transformOrigin = '';\n    this.removeImageSize();\n    this.removeDraggableImage();\n  }\n\n  setDraggableImage() {\n    const imgElement = this.getImageElement();\n\n    if (imgElement) {\n      imgElement.draggable = this.properties.draggableImage;\n    }\n  }\n\n  removeDraggableImage() {\n    const imgElement = this.getImageElement();\n\n    if (imgElement) {\n      imgElement.draggable = true;\n    }\n  }\n\n  setImageSize() {\n    const imgElement = this.element.getElementsByTagName(this.elementTarget);\n\n    if (imgElement.length) {\n      imgElement[0].style.maxWidth = '100%';\n      imgElement[0].style.maxHeight = '100%';\n      this.setAutoHeight();\n    }\n  }\n\n  setAutoHeight() {\n    const imgElement = this.element.getElementsByTagName(this.elementTarget);\n\n    if (!this.properties.autoHeight || !imgElement.length) {\n      return;\n    }\n\n    const imgNaturalWidth = imgElement[0].getAttribute(\"width\");\n    const imgNaturalHeight = imgElement[0].getAttribute(\"height\");\n    const sizeRatio = imgNaturalWidth / imgNaturalHeight;\n    const parentWidth = this.parentElement.offsetWidth;\n    imgElement[0].style.maxHeight = parentWidth / sizeRatio + \"px\";\n  }\n\n  removeImageSize() {\n    const imgElement = this.element.getElementsByTagName(this.elementTarget);\n\n    if (imgElement.length) {\n      imgElement[0].style.maxWidth = '';\n      imgElement[0].style.maxHeight = '';\n    }\n  }\n\n  getElementPosition() {\n    this.elementPosition = this.element.parentElement.getBoundingClientRect();\n  }\n\n  getTouchstartPosition(event) {\n    const {\n      clientX,\n      clientY\n    } = this.getClientPosition(event);\n    this.startX = clientX - this.elementPosition.left;\n    this.startY = clientY - this.elementPosition.top;\n  }\n\n  getClientPosition(event, index = 0) {\n    let clientX;\n    let clientY;\n\n    if (event.type === \"touchstart\" || event.type === \"touchmove\") {\n      clientX = event.touches[index].clientX;\n      clientY = event.touches[index].clientY;\n    }\n\n    if (event.type === \"mousedown\" || event.type === \"mousemove\") {\n      clientX = event.clientX;\n      clientY = event.clientY;\n    }\n\n    return {\n      clientX,\n      clientY\n    };\n  }\n\n  resetScale() {\n    this.scale = 1;\n    this.moveX = 0;\n    this.moveY = 0;\n    this.updateInitialValues();\n    this.transformElement(this.properties.transitionDuration);\n  }\n\n  updateInitialValues() {\n    this.initialScale = this.scale;\n    this.initialMoveX = this.moveX;\n    this.initialMoveY = this.moveY;\n  }\n\n  getDistance(touches) {\n    return Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2));\n  }\n\n  getImageHeight() {\n    const img = this.element.getElementsByTagName(this.elementTarget)[0];\n    return img.offsetHeight;\n  }\n\n  getImageWidth() {\n    const img = this.element.getElementsByTagName(this.elementTarget)[0];\n    return img.offsetWidth;\n  }\n\n  transformElement(duration) {\n    this.element.style.transition = \"all \" + duration + \"ms\";\n    this.element.style.transform = \"matrix(\" + Number(this.scale) + \", 0, 0, \" + Number(this.scale) + \", \" + Number(this.moveX) + \", \" + Number(this.moveY) + \")\";\n  }\n\n  isTouchScreen() {\n    const prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\n\n    if ('ontouchstart' in window) {\n      return true;\n    } // include the 'heartz' as a way to have a non matching MQ to help terminate the join\n    // https://git.io/vznFH\n\n\n    const query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\n    return this.getMatchMedia(query);\n  }\n\n  getMatchMedia(query) {\n    return window.matchMedia(query).matches;\n  }\n\n  isDragging() {\n    if (this.properties.disablePan) {\n      return false;\n    }\n\n    const imgHeight = this.getImageHeight();\n    const imgWidth = this.getImageWidth();\n\n    if (this.scale > 1) {\n      return imgHeight * this.scale > this.parentElement.offsetHeight || imgWidth * this.scale > this.parentElement.offsetWidth;\n    }\n\n    if (this.scale === 1) {\n      return imgHeight > this.parentElement.offsetHeight || imgWidth > this.parentElement.offsetWidth;\n    }\n\n    return undefined;\n  }\n\n  detectLimitZoom() {\n    this.maxScale = this.defaultMaxScale;\n\n    if (this.properties.limitZoom === \"original image size\" && this.elementTarget === \"IMG\") {\n      // We are waiting for the element with the image to be available\n      this.pollLimitZoomForOriginalImage();\n    }\n  }\n\n  pollLimitZoomForOriginalImage() {\n    let poll = setInterval(() => {\n      let maxScaleForOriginalImage = this.getMaxScaleForOriginalImage();\n\n      if (typeof maxScaleForOriginalImage === 'number') {\n        this.maxScale = maxScaleForOriginalImage;\n        clearInterval(poll);\n      }\n    }, 10);\n  }\n\n  getMaxScaleForOriginalImage() {\n    let maxScale;\n    let img = this.element.getElementsByTagName(\"img\")[0];\n\n    if (img.naturalWidth && img.offsetWidth) {\n      maxScale = img.naturalWidth / img.offsetWidth;\n    }\n\n    return maxScale;\n  }\n\n  getImageElement() {\n    const imgElement = this.element.getElementsByTagName(this.elementTarget);\n\n    if (imgElement.length) {\n      return imgElement[0];\n    }\n  }\n\n  toggleZoom(event = false) {\n    if (this.initialScale === 1) {\n      if (event && event.changedTouches) {\n        if (this.properties.doubleTapScale === undefined) {\n          return;\n        }\n\n        const changedTouches = event.changedTouches;\n        this.scale = this.initialScale * this.properties.doubleTapScale;\n        this.moveX = this.initialMoveX - (changedTouches[0].clientX - this.elementPosition.left) * (this.properties.doubleTapScale - 1);\n        this.moveY = this.initialMoveY - (changedTouches[0].clientY - this.elementPosition.top) * (this.properties.doubleTapScale - 1);\n      } else {\n        let zoomControlScale = this.properties.zoomControlScale || 0;\n        this.scale = this.initialScale * (zoomControlScale + 1);\n        this.moveX = this.initialMoveX - this.element.offsetWidth * (this.scale - 1) / 2;\n        this.moveY = this.initialMoveY - this.element.offsetHeight * (this.scale - 1) / 2;\n      }\n\n      this.centeringImage();\n      this.updateInitialValues();\n      this.transformElement(this.properties.transitionDuration);\n    } else {\n      this.resetScale();\n    }\n  }\n\n  setZoom(properties) {\n    this.scale = properties.scale;\n    let xCenter;\n    let yCenter;\n    let visibleAreaWidth = this.element.offsetWidth;\n    let visibleAreaHeight = this.element.offsetHeight;\n    let scalingPercent = visibleAreaWidth * this.scale / (visibleAreaWidth * this.initialScale);\n\n    if (properties.center) {\n      xCenter = properties.center[0];\n      yCenter = properties.center[1];\n    } else {\n      xCenter = visibleAreaWidth / 2 - this.initialMoveX;\n      yCenter = visibleAreaHeight / 2 - this.initialMoveY;\n    }\n\n    this.moveX = this.initialMoveX - (scalingPercent * xCenter - xCenter);\n    this.moveY = this.initialMoveY - (scalingPercent * yCenter - yCenter);\n    this.centeringImage();\n    this.updateInitialValues();\n    this.transformElement(this.properties.transitionDuration);\n  }\n\n  alignImage() {\n    const isMoveChanged = this.centeringImage();\n\n    if (isMoveChanged) {\n      this.updateInitialValues();\n      this.transformElement(this.properties.transitionDuration);\n    }\n  }\n\n  destroy() {\n    this.removeBasicStyles();\n    this.touches.destroy();\n  }\n\n  getPropertiesValue(propertyName) {\n    if (this.properties && this.properties[propertyName]) {\n      return this.properties[propertyName];\n    } else {\n      return defaultProperties[propertyName];\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}